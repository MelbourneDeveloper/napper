---
layout: layouts/base.njk
title: "Napper — CLI-First API Testing for VS Code"
description: "Napper is a free, open-source API testing tool that runs from the command line and integrates natively with VS Code. A modern alternative to Postman and Bruno with F# scripting, declarative assertions, and CI/CD integration."
permalink: /
---

{# ---- Hero ---- #}
<section class="hero">
  <div class="hero-content">
    <img src="/assets/images/logo.png" alt="Napper logo — open-source CLI-first API testing tool for VS Code" class="hero-logo" width="80" height="80">
    <h1>API Testing,<br>Supercharged.</h1>
    <p class="hero-subtitle">
      Napper is a free, open-source API testing tool that runs from the command line and integrates natively with VS Code.
      Define HTTP requests as plain text <code>.nap</code> files, add declarative assertions, chain them into test suites, and run everything in CI/CD with JUnit output.
      As simple as curl for quick requests. As powerful as F# for full test suites.
    </p>
    <div class="hero-actions">
      <a href="/docs/installation/" class="btn btn-primary">Get Started</a>
      <a href="https://github.com/MelbourneDeveloper/ApiTesting" class="btn btn-secondary">View on GitHub</a>
    </div>

    {# ---- Code Demo ---- #}
    <div class="code-demo">
      <div class="code-demo-window">
        <div class="code-demo-titlebar">
          <span class="code-demo-dot"></span>
          <span class="code-demo-dot"></span>
          <span class="code-demo-dot"></span>
          <span class="code-demo-filename">get-users.nap</span>
        </div>
        <div class="code-demo-body">
          <div><span class="section">[meta]</span></div>
          <div><span class="kw">name</span> <span class="op">=</span> <span class="str">Get all users</span></div>
          <div>&nbsp;</div>
          <div><span class="section">[request]</span></div>
          <div><span class="method">GET</span> <span class="url">https://api.example.com/users</span></div>
          <div>&nbsp;</div>
          <div><span class="section">[request.headers]</span></div>
          <div><span class="kw">Authorization</span> <span class="op">=</span> <span class="str">Bearer {{"{{token}}"}}</span></div>
          <div>&nbsp;</div>
          <div><span class="section">[assert]</span></div>
          <div><span class="kw">status</span> <span class="op">=</span> <span class="num">200</span></div>
          <div><span class="kw">body.length</span> <span class="op">></span> <span class="num">0</span></div>
          <div><span class="kw">duration</span> <span class="op"><</span> <span class="num">500ms</span></div>
        </div>
      </div>
    </div>
  </div>
</section>

{# ---- Screenshot Showcase ---- #}
<section class="section">
  <div class="screenshot-showcase">
    <img src="/assets/images/screenshot-playlist.png" alt="Napper VS Code extension running a playlist with test results, response headers, and body inspection" width="900" loading="lazy">
    <p class="screenshot-caption">Run playlists, inspect responses, and verify assertions — all inside VS Code.</p>
  </div>
</section>

{# ---- Features Grid ---- #}
<section class="section-alt">
  <div class="section">
    <div class="section-heading">
      <h2>What can Napper do?</h2>
      <p>Everything you need for API testing. Nothing you don't.</p>
    </div>

    <div class="features-grid">
      <div class="feature-card">
        <div class="feature-icon" style="background: rgba(13,148,136,0.12); color: #0D9488;">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></svg>
        </div>
        <h3>CLI First</h3>
        <p>The command line is the product. Run requests, execute test suites, and integrate with CI/CD pipelines from your terminal.</p>
      </div>

      <div class="feature-card">
        <div class="feature-icon" style="background: rgba(232,115,74,0.12); color: #E8734A;">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>
        </div>
        <h3>VS Code Native</h3>
        <p>Full extension with syntax highlighting, request explorer, environment switching, and Test Explorer integration. Never leave your editor.</p>
      </div>

      <div class="feature-card">
        <div class="feature-icon" style="background: rgba(27,73,101,0.12); color: #1B4965;">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path></svg>
        </div>
        <h3>F# Scripting</h3>
        <p>Full power of F# for pre/post request hooks. Extract tokens, build dynamic payloads, orchestrate complex flows. No limits.</p>
      </div>

      <div class="feature-card">
        <div class="feature-icon" style="background: rgba(245,166,35,0.12); color: #F5A623;">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
        </div>
        <h3>Declarative Assertions</h3>
        <p>Assert on status codes, JSON paths, headers, and response times with a clean, readable syntax. No scripting required for simple checks.</p>
      </div>

      <div class="feature-card">
        <div class="feature-icon" style="background: rgba(13,148,136,0.12); color: #0D9488;">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
        </div>
        <h3>Composable Playlists</h3>
        <p>Chain requests into test suites with <code>.naplist</code> files. Nest playlists, reference folders, pass variables between steps.</p>
      </div>

      <div class="feature-card">
        <div class="feature-icon" style="background: rgba(232,115,74,0.12); color: #E8734A;">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path></svg>
        </div>
        <h3>Plain Text, Git Friendly</h3>
        <p>Every request is a <code>.nap</code> file. Every environment is a <code>.napenv</code> file. Version control everything. No binary blobs, no lock-in.</p>
      </div>
    </div>
  </div>
</section>

{# ---- Comparison ---- #}
<section class="section">
  <div class="section-heading">
    <h2>How does Napper compare to other API testing tools?</h2>
    <p>See how Napper stacks up against Postman, Bruno, and .http files.</p>
  </div>

  <div class="comparison-wrapper">
    <table class="comparison-table">
      <thead>
        <tr>
          <th>Feature</th>
          <th>Napper</th>
          <th>Postman</th>
          <th>Bruno</th>
          <th>.http files</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>CLI-first design</td>
          <td><span class="check">Yes</span></td>
          <td><span class="cross">No</span></td>
          <td><span class="cross">GUI-first</span></td>
          <td><span class="cross">No CLI</span></td>
        </tr>
        <tr>
          <td>VS Code integration</td>
          <td><span class="check">Native</span></td>
          <td><span class="cross">Separate app</span></td>
          <td><span class="cross">Separate app</span></td>
          <td><span class="check">Built-in</span></td>
        </tr>
        <tr>
          <td>Git-friendly files</td>
          <td><span class="check">Yes</span></td>
          <td><span class="cross">JSON blobs</span></td>
          <td><span class="check">Yes</span></td>
          <td><span class="check">Yes</span></td>
        </tr>
        <tr>
          <td>Assertions</td>
          <td><span class="check">Declarative + scripts</span></td>
          <td><span class="check">JS scripts</span></td>
          <td><span class="check">JS scripts</span></td>
          <td><span class="cross">None</span></td>
        </tr>
        <tr>
          <td>Full scripting language</td>
          <td><span class="check">F# (.fsx)</span></td>
          <td><span class="cross">Sandboxed JS</span></td>
          <td><span class="cross">Sandboxed JS</span></td>
          <td><span class="cross">None</span></td>
        </tr>
        <tr>
          <td>CI/CD output formats</td>
          <td><span class="check">JUnit, TAP, JSON</span></td>
          <td><span class="check">Via Newman</span></td>
          <td><span class="check">Via CLI</span></td>
          <td><span class="cross">None</span></td>
        </tr>
        <tr>
          <td>Test Explorer</td>
          <td><span class="check">Native</span></td>
          <td><span class="cross">No</span></td>
          <td><span class="cross">No</span></td>
          <td><span class="cross">No</span></td>
        </tr>
        <tr>
          <td>Free &amp; open source</td>
          <td><span class="check">Yes</span></td>
          <td><span class="cross">Freemium</span></td>
          <td><span class="check">Yes</span></td>
          <td><span class="check">Yes</span></td>
        </tr>
        <tr>
          <td>No account required</td>
          <td><span class="check">Yes</span></td>
          <td><span class="cross">Account needed</span></td>
          <td><span class="check">Yes</span></td>
          <td><span class="check">Yes</span></td>
        </tr>
      </tbody>
    </table>
  </div>
</section>

{# ---- Quick Examples ---- #}
<section class="section-alt">
  <div class="section">
    <div class="section-heading">
      <h2>How do you use Napper?</h2>
      <p>From one-liners to full test suites.</p>
    </div>

    <div class="features-grid" style="grid-template-columns: repeat(auto-fit, minmax(min(100%, 320px), 1fr));">
      <div>
        <h3>Minimal request</h3>
        <div class="code-demo-window">
          <div class="code-demo-titlebar">
            <span class="code-demo-dot"></span>
            <span class="code-demo-dot"></span>
            <span class="code-demo-dot"></span>
            <span class="code-demo-filename">health.nap</span>
          </div>
          <div class="code-demo-body">
            <div><span class="method">GET</span> <span class="url">https://api.example.com/health</span></div>
          </div>
        </div>
      </div>

      <div>
        <h3>POST with body</h3>
        <div class="code-demo-window">
          <div class="code-demo-titlebar">
            <span class="code-demo-dot"></span>
            <span class="code-demo-dot"></span>
            <span class="code-demo-dot"></span>
            <span class="code-demo-filename">create-user.nap</span>
          </div>
          <div class="code-demo-body">
            <div><span class="section">[request]</span></div>
            <div><span class="method">POST</span> <span class="url">{{"{{baseUrl}}"}}/users</span></div>
            <div>&nbsp;</div>
            <div><span class="section">[request.headers]</span></div>
            <div><span class="kw">Content-Type</span> <span class="op">=</span> <span class="str">application/json</span></div>
            <div>&nbsp;</div>
            <div><span class="section">[request.body]</span></div>
            <div><span class="str">"""</span></div>
            <div><span class="str">{</span></div>
            <div><span class="str">&nbsp;&nbsp;"name": "Ada Lovelace",</span></div>
            <div><span class="str">&nbsp;&nbsp;"email": "ada@example.com"</span></div>
            <div><span class="str">}</span></div>
            <div><span class="str">"""</span></div>
            <div>&nbsp;</div>
            <div><span class="section">[assert]</span></div>
            <div><span class="kw">status</span> <span class="op">=</span> <span class="num">201</span></div>
            <div><span class="kw">body.id</span> <span class="val">exists</span></div>
          </div>
        </div>
      </div>

      <div>
        <h3>Run from CLI</h3>
        <div class="code-demo-window">
          <div class="code-demo-titlebar">
            <span class="code-demo-dot"></span>
            <span class="code-demo-dot"></span>
            <span class="code-demo-dot"></span>
            <span class="code-demo-filename">terminal</span>
          </div>
          <div class="code-demo-body">
            <div><span class="comment"># Run a single request</span></div>
            <div><span class="method">$</span> <span class="kw">napper</span> <span class="str">run</span> <span class="url">./health.nap</span></div>
            <div>&nbsp;</div>
            <div><span class="comment"># Run a full test suite</span></div>
            <div><span class="method">$</span> <span class="kw">napper</span> <span class="str">run</span> <span class="url">./smoke.naplist</span></div>
            <div>&nbsp;</div>
            <div><span class="comment"># With environment + JUnit output</span></div>
            <div><span class="method">$</span> <span class="kw">napper</span> <span class="str">run</span> <span class="url">./tests/</span> <span class="op">--env</span> <span class="val">staging</span> <span class="op">--output</span> <span class="val">junit</span></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

{# ---- FAQ Section ---- #}
<section class="section">
  <div class="section-heading">
    <h2>Frequently Asked Questions</h2>
  </div>

  <div class="faq-list">
    <div class="faq-item">
      <h3>What is Napper?</h3>
      <p>Napper is a free, open-source, CLI-first API testing tool that integrates natively with VS Code. It lets you define HTTP requests as plain text <code>.nap</code> files, add declarative assertions to validate responses, compose requests into test suites with <code>.naplist</code> files, and run everything from the terminal or your editor. It uses F# for advanced scripting and outputs JUnit XML for CI/CD pipelines.</p>
    </div>

    <div class="faq-item">
      <h3>Is Napper free?</h3>
      <p>Yes. Napper is completely free and open source under the MIT license. There are no paid tiers, no account requirements, and no feature gates. The CLI binary and the VS Code extension are both free to use.</p>
    </div>

    <div class="faq-item">
      <h3>How is Napper different from Postman?</h3>
      <p>Postman is a GUI-first tool that requires an account, stores collections as JSON, and locks advanced features behind a paywall. Napper is CLI-first, stores everything as plain text files in your repository, requires no account, and is completely free. Napper also provides F# scripting instead of sandboxed JavaScript, and integrates directly into VS Code with native Test Explorer support.</p>
    </div>

    <div class="faq-item">
      <h3>How is Napper different from Bruno?</h3>
      <p>Bruno is an excellent open-source alternative to Postman, but it is GUI-first with a standalone desktop application. Napper puts the CLI first and lives inside VS Code. For scripting, Bruno offers sandboxed JavaScript while Napper gives you full F# Interactive with access to the entire .NET ecosystem. Both store requests as plain text files.</p>
    </div>

    <div class="faq-item">
      <h3>Does Napper work with CI/CD pipelines?</h3>
      <p>Yes. Napper is designed for CI/CD from the ground up. The CLI binary is self-contained with no runtime dependencies. It outputs JUnit XML, TAP, JSON, and NDJSON formats. It integrates with GitHub Actions, GitLab CI, Jenkins, Azure DevOps, and any platform that supports standard test output formats. Exit code 0 means all assertions passed, exit code 1 means a test failed.</p>
    </div>

    <div class="faq-item">
      <h3>What scripting language does Napper use?</h3>
      <p>Napper uses F# Interactive (<code>.fsx</code> scripts) for pre-request and post-request hooks. Unlike the sandboxed JavaScript in Postman and Bruno, F# scripts in Napper have full access to the .NET ecosystem. You can parse XML, call databases, generate cryptographic tokens, validate complex schemas, and use any NuGet package.</p>
    </div>

    <div class="faq-item">
      <h3>What file formats does Napper use?</h3>
      <p>Napper uses three plain text file formats: <code>.nap</code> files for individual HTTP requests, <code>.naplist</code> files for composing requests into ordered test suites, and <code>.napenv</code> files for environment-specific variables like base URLs and tokens. All files are human-readable, git-friendly, and produce clean diffs in code reviews.</p>
    </div>

    <div class="faq-item">
      <h3>Does Napper require VS Code?</h3>
      <p>No. The Napper CLI runs independently from any editor or IDE. You can use it entirely from the terminal. The VS Code extension is optional and provides syntax highlighting, a request explorer, environment switching, and Test Explorer integration for developers who prefer working in an editor.</p>
    </div>
  </div>
</section>

{# ---- Install CTA ---- #}
<section class="install-banner">
  <h2>Ready to ship faster?</h2>
  <p>Install from the VS Code Marketplace or grab the CLI binary.</p>
  <div class="install-command">
    <span class="prompt">$</span> code --install-extension nimblesite.napper
  </div>
  <br>
  <div class="hero-actions">
    <a href="https://marketplace.visualstudio.com/items?itemName=nimblesite.napper" class="btn btn-primary">Install Extension</a>
    <a href="/docs/installation/" class="btn btn-secondary" style="color: #FFFFFF; border-color: rgba(255,255,255,0.4);">Read the Docs</a>
  </div>
</section>

{# ---- FAQPage + SoftwareApplication Schema ---- #}
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "FAQPage",
  "mainEntity": [
    {
      "@type": "Question",
      "name": "What is Napper?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Napper is a free, open-source, CLI-first API testing tool that integrates natively with VS Code. It lets you define HTTP requests as plain text .nap files, add declarative assertions to validate responses, compose requests into test suites with .naplist files, and run everything from the terminal or your editor. It uses F# for advanced scripting and outputs JUnit XML for CI/CD pipelines."
      }
    },
    {
      "@type": "Question",
      "name": "Is Napper free?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Yes. Napper is completely free and open source under the MIT license. There are no paid tiers, no account requirements, and no feature gates. The CLI binary and the VS Code extension are both free to use."
      }
    },
    {
      "@type": "Question",
      "name": "How is Napper different from Postman?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Postman is a GUI-first tool that requires an account, stores collections as JSON, and locks advanced features behind a paywall. Napper is CLI-first, stores everything as plain text files in your repository, requires no account, and is completely free. Napper also provides F# scripting instead of sandboxed JavaScript, and integrates directly into VS Code with native Test Explorer support."
      }
    },
    {
      "@type": "Question",
      "name": "How is Napper different from Bruno?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Bruno is an excellent open-source alternative to Postman, but it is GUI-first with a standalone desktop application. Napper puts the CLI first and lives inside VS Code. For scripting, Bruno offers sandboxed JavaScript while Napper gives you full F# Interactive with access to the entire .NET ecosystem."
      }
    },
    {
      "@type": "Question",
      "name": "Does Napper work with CI/CD pipelines?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Yes. Napper is designed for CI/CD from the ground up. The CLI binary is self-contained with no runtime dependencies. It outputs JUnit XML, TAP, JSON, and NDJSON formats. It integrates with GitHub Actions, GitLab CI, Jenkins, Azure DevOps, and any platform that supports standard test output formats."
      }
    },
    {
      "@type": "Question",
      "name": "What scripting language does Napper use?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Napper uses F# Interactive (.fsx scripts) for pre-request and post-request hooks. Unlike the sandboxed JavaScript in Postman and Bruno, F# scripts in Napper have full access to the .NET ecosystem."
      }
    },
    {
      "@type": "Question",
      "name": "What file formats does Napper use?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Napper uses three plain text file formats: .nap files for individual HTTP requests, .naplist files for composing requests into ordered test suites, and .napenv files for environment-specific variables like base URLs and tokens."
      }
    },
    {
      "@type": "Question",
      "name": "Does Napper require VS Code?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "No. The Napper CLI runs independently from any editor or IDE. You can use it entirely from the terminal. The VS Code extension is optional and provides syntax highlighting, a request explorer, environment switching, and Test Explorer integration."
      }
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "Napper",
  "description": "CLI-first API testing tool for VS Code with F# scripting, declarative assertions, and CI/CD integration.",
  "url": "https://napper.dev",
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Windows, macOS, Linux",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "license": "https://opensource.org/licenses/MIT",
  "downloadUrl": "https://github.com/MelbourneDeveloper/ApiTesting/releases",
  "installUrl": "https://marketplace.visualstudio.com/items?itemName=nimblesite.napper",
  "author": {
    "@type": "Person",
    "name": "Christian Findlay"
  },
  "programmingLanguage": "F#",
  "featureList": [
    "CLI-first HTTP API testing",
    "VS Code extension with syntax highlighting",
    "Declarative assertions on status, body, headers, timing",
    "F# scripting for advanced request flows",
    "Composable test suites with .naplist playlists",
    "Environment variable management with .napenv files",
    "JUnit XML, TAP, JSON, NDJSON output for CI/CD",
    "Native VS Code Test Explorer integration"
  ]
}
</script>
